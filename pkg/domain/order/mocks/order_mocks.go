// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jizambrana5/quickfix-back/pkg/domain"
	"sync"
	"time"
)

// StorageMock is a mock implementation of order.Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked order.Storage
//		mockedStorage := &StorageMock{
//			CreateOrderFunc: func(ctx context.Context, order domain.Order) (domain.Order, error) {
//				panic("mock out the CreateOrder method")
//			},
//			FindOrdersByProfessionalIDFunc: func(ctx context.Context, professionalID uint64) ([]domain.Order, error) {
//				panic("mock out the FindOrdersByProfessionalID method")
//			},
//			FindOrdersByScheduleFunc: func(ctx context.Context, scheduleTo time.Time, userID uint64, professionalID uint64) ([]domain.Order, error) {
//				panic("mock out the FindOrdersBySchedule method")
//			},
//			FindOrdersByStatusFunc: func(ctx context.Context, status string) ([]domain.Order, error) {
//				panic("mock out the FindOrdersByStatus method")
//			},
//			FindOrdersByUserIDFunc: func(ctx context.Context, userID uint64) ([]domain.Order, error) {
//				panic("mock out the FindOrdersByUserID method")
//			},
//			GetOrderFunc: func(ctx context.Context, ID string) (domain.Order, error) {
//				panic("mock out the GetOrder method")
//			},
//			UpdateOrderFunc: func(ctx context.Context, order domain.Order) (domain.Order, error) {
//				panic("mock out the UpdateOrder method")
//			},
//		}
//
//		// use mockedStorage in code that requires order.Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// CreateOrderFunc mocks the CreateOrder method.
	CreateOrderFunc func(ctx context.Context, order domain.Order) (domain.Order, error)

	// FindOrdersByProfessionalIDFunc mocks the FindOrdersByProfessionalID method.
	FindOrdersByProfessionalIDFunc func(ctx context.Context, professionalID uint64) ([]domain.Order, error)

	// FindOrdersByScheduleFunc mocks the FindOrdersBySchedule method.
	FindOrdersByScheduleFunc func(ctx context.Context, scheduleTo time.Time, userID uint64, professionalID uint64) ([]domain.Order, error)

	// FindOrdersByStatusFunc mocks the FindOrdersByStatus method.
	FindOrdersByStatusFunc func(ctx context.Context, status string) ([]domain.Order, error)

	// FindOrdersByUserIDFunc mocks the FindOrdersByUserID method.
	FindOrdersByUserIDFunc func(ctx context.Context, userID uint64) ([]domain.Order, error)

	// GetOrderFunc mocks the GetOrder method.
	GetOrderFunc func(ctx context.Context, ID string) (domain.Order, error)

	// UpdateOrderFunc mocks the UpdateOrder method.
	UpdateOrderFunc func(ctx context.Context, order domain.Order) (domain.Order, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateOrder holds details about calls to the CreateOrder method.
		CreateOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order domain.Order
		}
		// FindOrdersByProfessionalID holds details about calls to the FindOrdersByProfessionalID method.
		FindOrdersByProfessionalID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProfessionalID is the professionalID argument value.
			ProfessionalID uint64
		}
		// FindOrdersBySchedule holds details about calls to the FindOrdersBySchedule method.
		FindOrdersBySchedule []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ScheduleTo is the scheduleTo argument value.
			ScheduleTo time.Time
			// UserID is the userID argument value.
			UserID uint64
			// ProfessionalID is the professionalID argument value.
			ProfessionalID uint64
		}
		// FindOrdersByStatus holds details about calls to the FindOrdersByStatus method.
		FindOrdersByStatus []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Status is the status argument value.
			Status string
		}
		// FindOrdersByUserID holds details about calls to the FindOrdersByUserID method.
		FindOrdersByUserID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint64
		}
		// GetOrder holds details about calls to the GetOrder method.
		GetOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// UpdateOrder holds details about calls to the UpdateOrder method.
		UpdateOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order domain.Order
		}
	}
	lockCreateOrder                sync.RWMutex
	lockFindOrdersByProfessionalID sync.RWMutex
	lockFindOrdersBySchedule       sync.RWMutex
	lockFindOrdersByStatus         sync.RWMutex
	lockFindOrdersByUserID         sync.RWMutex
	lockGetOrder                   sync.RWMutex
	lockUpdateOrder                sync.RWMutex
}

// CreateOrder calls CreateOrderFunc.
func (mock *StorageMock) CreateOrder(ctx context.Context, order domain.Order) (domain.Order, error) {
	if mock.CreateOrderFunc == nil {
		panic("StorageMock.CreateOrderFunc: method is nil but Storage.CreateOrder was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order domain.Order
	}{
		Ctx:   ctx,
		Order: order,
	}
	mock.lockCreateOrder.Lock()
	mock.calls.CreateOrder = append(mock.calls.CreateOrder, callInfo)
	mock.lockCreateOrder.Unlock()
	return mock.CreateOrderFunc(ctx, order)
}

// CreateOrderCalls gets all the calls that were made to CreateOrder.
// Check the length with:
//
//	len(mockedStorage.CreateOrderCalls())
func (mock *StorageMock) CreateOrderCalls() []struct {
	Ctx   context.Context
	Order domain.Order
} {
	var calls []struct {
		Ctx   context.Context
		Order domain.Order
	}
	mock.lockCreateOrder.RLock()
	calls = mock.calls.CreateOrder
	mock.lockCreateOrder.RUnlock()
	return calls
}

// FindOrdersByProfessionalID calls FindOrdersByProfessionalIDFunc.
func (mock *StorageMock) FindOrdersByProfessionalID(ctx context.Context, professionalID uint64) ([]domain.Order, error) {
	if mock.FindOrdersByProfessionalIDFunc == nil {
		panic("StorageMock.FindOrdersByProfessionalIDFunc: method is nil but Storage.FindOrdersByProfessionalID was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ProfessionalID uint64
	}{
		Ctx:            ctx,
		ProfessionalID: professionalID,
	}
	mock.lockFindOrdersByProfessionalID.Lock()
	mock.calls.FindOrdersByProfessionalID = append(mock.calls.FindOrdersByProfessionalID, callInfo)
	mock.lockFindOrdersByProfessionalID.Unlock()
	return mock.FindOrdersByProfessionalIDFunc(ctx, professionalID)
}

// FindOrdersByProfessionalIDCalls gets all the calls that were made to FindOrdersByProfessionalID.
// Check the length with:
//
//	len(mockedStorage.FindOrdersByProfessionalIDCalls())
func (mock *StorageMock) FindOrdersByProfessionalIDCalls() []struct {
	Ctx            context.Context
	ProfessionalID uint64
} {
	var calls []struct {
		Ctx            context.Context
		ProfessionalID uint64
	}
	mock.lockFindOrdersByProfessionalID.RLock()
	calls = mock.calls.FindOrdersByProfessionalID
	mock.lockFindOrdersByProfessionalID.RUnlock()
	return calls
}

// FindOrdersBySchedule calls FindOrdersByScheduleFunc.
func (mock *StorageMock) FindOrdersBySchedule(ctx context.Context, scheduleTo time.Time, userID uint64, professionalID uint64) ([]domain.Order, error) {
	if mock.FindOrdersByScheduleFunc == nil {
		panic("StorageMock.FindOrdersByScheduleFunc: method is nil but Storage.FindOrdersBySchedule was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ScheduleTo     time.Time
		UserID         uint64
		ProfessionalID uint64
	}{
		Ctx:            ctx,
		ScheduleTo:     scheduleTo,
		UserID:         userID,
		ProfessionalID: professionalID,
	}
	mock.lockFindOrdersBySchedule.Lock()
	mock.calls.FindOrdersBySchedule = append(mock.calls.FindOrdersBySchedule, callInfo)
	mock.lockFindOrdersBySchedule.Unlock()
	return mock.FindOrdersByScheduleFunc(ctx, scheduleTo, userID, professionalID)
}

// FindOrdersByScheduleCalls gets all the calls that were made to FindOrdersBySchedule.
// Check the length with:
//
//	len(mockedStorage.FindOrdersByScheduleCalls())
func (mock *StorageMock) FindOrdersByScheduleCalls() []struct {
	Ctx            context.Context
	ScheduleTo     time.Time
	UserID         uint64
	ProfessionalID uint64
} {
	var calls []struct {
		Ctx            context.Context
		ScheduleTo     time.Time
		UserID         uint64
		ProfessionalID uint64
	}
	mock.lockFindOrdersBySchedule.RLock()
	calls = mock.calls.FindOrdersBySchedule
	mock.lockFindOrdersBySchedule.RUnlock()
	return calls
}

// FindOrdersByStatus calls FindOrdersByStatusFunc.
func (mock *StorageMock) FindOrdersByStatus(ctx context.Context, status string) ([]domain.Order, error) {
	if mock.FindOrdersByStatusFunc == nil {
		panic("StorageMock.FindOrdersByStatusFunc: method is nil but Storage.FindOrdersByStatus was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Status string
	}{
		Ctx:    ctx,
		Status: status,
	}
	mock.lockFindOrdersByStatus.Lock()
	mock.calls.FindOrdersByStatus = append(mock.calls.FindOrdersByStatus, callInfo)
	mock.lockFindOrdersByStatus.Unlock()
	return mock.FindOrdersByStatusFunc(ctx, status)
}

// FindOrdersByStatusCalls gets all the calls that were made to FindOrdersByStatus.
// Check the length with:
//
//	len(mockedStorage.FindOrdersByStatusCalls())
func (mock *StorageMock) FindOrdersByStatusCalls() []struct {
	Ctx    context.Context
	Status string
} {
	var calls []struct {
		Ctx    context.Context
		Status string
	}
	mock.lockFindOrdersByStatus.RLock()
	calls = mock.calls.FindOrdersByStatus
	mock.lockFindOrdersByStatus.RUnlock()
	return calls
}

// FindOrdersByUserID calls FindOrdersByUserIDFunc.
func (mock *StorageMock) FindOrdersByUserID(ctx context.Context, userID uint64) ([]domain.Order, error) {
	if mock.FindOrdersByUserIDFunc == nil {
		panic("StorageMock.FindOrdersByUserIDFunc: method is nil but Storage.FindOrdersByUserID was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uint64
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockFindOrdersByUserID.Lock()
	mock.calls.FindOrdersByUserID = append(mock.calls.FindOrdersByUserID, callInfo)
	mock.lockFindOrdersByUserID.Unlock()
	return mock.FindOrdersByUserIDFunc(ctx, userID)
}

// FindOrdersByUserIDCalls gets all the calls that were made to FindOrdersByUserID.
// Check the length with:
//
//	len(mockedStorage.FindOrdersByUserIDCalls())
func (mock *StorageMock) FindOrdersByUserIDCalls() []struct {
	Ctx    context.Context
	UserID uint64
} {
	var calls []struct {
		Ctx    context.Context
		UserID uint64
	}
	mock.lockFindOrdersByUserID.RLock()
	calls = mock.calls.FindOrdersByUserID
	mock.lockFindOrdersByUserID.RUnlock()
	return calls
}

// GetOrder calls GetOrderFunc.
func (mock *StorageMock) GetOrder(ctx context.Context, ID string) (domain.Order, error) {
	if mock.GetOrderFunc == nil {
		panic("StorageMock.GetOrderFunc: method is nil but Storage.GetOrder was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetOrder.Lock()
	mock.calls.GetOrder = append(mock.calls.GetOrder, callInfo)
	mock.lockGetOrder.Unlock()
	return mock.GetOrderFunc(ctx, ID)
}

// GetOrderCalls gets all the calls that were made to GetOrder.
// Check the length with:
//
//	len(mockedStorage.GetOrderCalls())
func (mock *StorageMock) GetOrderCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetOrder.RLock()
	calls = mock.calls.GetOrder
	mock.lockGetOrder.RUnlock()
	return calls
}

// UpdateOrder calls UpdateOrderFunc.
func (mock *StorageMock) UpdateOrder(ctx context.Context, order domain.Order) (domain.Order, error) {
	if mock.UpdateOrderFunc == nil {
		panic("StorageMock.UpdateOrderFunc: method is nil but Storage.UpdateOrder was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order domain.Order
	}{
		Ctx:   ctx,
		Order: order,
	}
	mock.lockUpdateOrder.Lock()
	mock.calls.UpdateOrder = append(mock.calls.UpdateOrder, callInfo)
	mock.lockUpdateOrder.Unlock()
	return mock.UpdateOrderFunc(ctx, order)
}

// UpdateOrderCalls gets all the calls that were made to UpdateOrder.
// Check the length with:
//
//	len(mockedStorage.UpdateOrderCalls())
func (mock *StorageMock) UpdateOrderCalls() []struct {
	Ctx   context.Context
	Order domain.Order
} {
	var calls []struct {
		Ctx   context.Context
		Order domain.Order
	}
	mock.lockUpdateOrder.RLock()
	calls = mock.calls.UpdateOrder
	mock.lockUpdateOrder.RUnlock()
	return calls
}
