// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jizambrana5/quickfix-back/pkg/domain"
	"github.com/jizambrana5/quickfix-back/pkg/entities"
	"sync"
)

// StorageMock is a mock implementation of user.Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked user.Storage
//		mockedStorage := &StorageMock{
//			CreateProfessionalFunc: func(ctx context.Context, professional domain.Professional) (domain.Professional, error) {
//				panic("mock out the CreateProfessional method")
//			},
//			CreateSessionFunc: func(ctx context.Context, session entities.Session) error {
//				panic("mock out the CreateSession method")
//			},
//			CreateUserFunc: func(ctx context.Context, user domain.User) (domain.User, error) {
//				panic("mock out the CreateUser method")
//			},
//			DeleteExpiredSessionsFunc: func(ctx context.Context) error {
//				panic("mock out the DeleteExpiredSessions method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, token string) error {
//				panic("mock out the DeleteSession method")
//			},
//			FindProfessionalsByLocationFunc: func(ctx context.Context, department string, district string) ([]domain.Professional, error) {
//				panic("mock out the FindProfessionalsByLocation method")
//			},
//			FindProfessionalsByLocationAndProfessionFunc: func(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error) {
//				panic("mock out the FindProfessionalsByLocationAndProfession method")
//			},
//			GetProfessionalByEmailFunc: func(ctx context.Context, email string) (domain.Professional, error) {
//				panic("mock out the GetProfessionalByEmail method")
//			},
//			GetProfessionalByIDFunc: func(ctx context.Context, ID uint64) (domain.Professional, error) {
//				panic("mock out the GetProfessionalByID method")
//			},
//			GetProfessionalByUsernameFunc: func(ctx context.Context, username string) (domain.Professional, error) {
//				panic("mock out the GetProfessionalByUsername method")
//			},
//			GetSessionByTokenFunc: func(ctx context.Context, token string) (entities.Session, error) {
//				panic("mock out the GetSessionByToken method")
//			},
//			GetUserByEmailFunc: func(ctx context.Context, email string) (domain.User, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIDFunc: func(ctx context.Context, ID uint64) (domain.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			GetUserByUsernameFunc: func(ctx context.Context, username string) (domain.User, error) {
//				panic("mock out the GetUserByUsername method")
//			},
//		}
//
//		// use mockedStorage in code that requires user.Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// CreateProfessionalFunc mocks the CreateProfessional method.
	CreateProfessionalFunc func(ctx context.Context, professional domain.Professional) (domain.Professional, error)

	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, session entities.Session) error

	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(ctx context.Context, user domain.User) (domain.User, error)

	// DeleteExpiredSessionsFunc mocks the DeleteExpiredSessions method.
	DeleteExpiredSessionsFunc func(ctx context.Context) error

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, token string) error

	// FindProfessionalsByLocationFunc mocks the FindProfessionalsByLocation method.
	FindProfessionalsByLocationFunc func(ctx context.Context, department string, district string) ([]domain.Professional, error)

	// FindProfessionalsByLocationAndProfessionFunc mocks the FindProfessionalsByLocationAndProfession method.
	FindProfessionalsByLocationAndProfessionFunc func(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error)

	// GetProfessionalByEmailFunc mocks the GetProfessionalByEmail method.
	GetProfessionalByEmailFunc func(ctx context.Context, email string) (domain.Professional, error)

	// GetProfessionalByIDFunc mocks the GetProfessionalByID method.
	GetProfessionalByIDFunc func(ctx context.Context, ID uint64) (domain.Professional, error)

	// GetProfessionalByUsernameFunc mocks the GetProfessionalByUsername method.
	GetProfessionalByUsernameFunc func(ctx context.Context, username string) (domain.Professional, error)

	// GetSessionByTokenFunc mocks the GetSessionByToken method.
	GetSessionByTokenFunc func(ctx context.Context, token string) (entities.Session, error)

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(ctx context.Context, email string) (domain.User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(ctx context.Context, ID uint64) (domain.User, error)

	// GetUserByUsernameFunc mocks the GetUserByUsername method.
	GetUserByUsernameFunc func(ctx context.Context, username string) (domain.User, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateProfessional holds details about calls to the CreateProfessional method.
		CreateProfessional []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Professional is the professional argument value.
			Professional domain.Professional
		}
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Session is the session argument value.
			Session entities.Session
		}
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// User is the user argument value.
			User domain.User
		}
		// DeleteExpiredSessions holds details about calls to the DeleteExpiredSessions method.
		DeleteExpiredSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// FindProfessionalsByLocation holds details about calls to the FindProfessionalsByLocation method.
		FindProfessionalsByLocation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Department is the department argument value.
			Department string
			// District is the district argument value.
			District string
		}
		// FindProfessionalsByLocationAndProfession holds details about calls to the FindProfessionalsByLocationAndProfession method.
		FindProfessionalsByLocationAndProfession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Department is the department argument value.
			Department string
			// District is the district argument value.
			District string
			// Profession is the profession argument value.
			Profession string
		}
		// GetProfessionalByEmail holds details about calls to the GetProfessionalByEmail method.
		GetProfessionalByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetProfessionalByID holds details about calls to the GetProfessionalByID method.
		GetProfessionalByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID uint64
		}
		// GetProfessionalByUsername holds details about calls to the GetProfessionalByUsername method.
		GetProfessionalByUsername []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
		// GetSessionByToken holds details about calls to the GetSessionByToken method.
		GetSessionByToken []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID uint64
		}
		// GetUserByUsername holds details about calls to the GetUserByUsername method.
		GetUserByUsername []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Username is the username argument value.
			Username string
		}
	}
	lockCreateProfessional                       sync.RWMutex
	lockCreateSession                            sync.RWMutex
	lockCreateUser                               sync.RWMutex
	lockDeleteExpiredSessions                    sync.RWMutex
	lockDeleteSession                            sync.RWMutex
	lockFindProfessionalsByLocation              sync.RWMutex
	lockFindProfessionalsByLocationAndProfession sync.RWMutex
	lockGetProfessionalByEmail                   sync.RWMutex
	lockGetProfessionalByID                      sync.RWMutex
	lockGetProfessionalByUsername                sync.RWMutex
	lockGetSessionByToken                        sync.RWMutex
	lockGetUserByEmail                           sync.RWMutex
	lockGetUserByID                              sync.RWMutex
	lockGetUserByUsername                        sync.RWMutex
}

// CreateProfessional calls CreateProfessionalFunc.
func (mock *StorageMock) CreateProfessional(ctx context.Context, professional domain.Professional) (domain.Professional, error) {
	if mock.CreateProfessionalFunc == nil {
		panic("StorageMock.CreateProfessionalFunc: method is nil but Storage.CreateProfessional was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		Professional domain.Professional
	}{
		Ctx:          ctx,
		Professional: professional,
	}
	mock.lockCreateProfessional.Lock()
	mock.calls.CreateProfessional = append(mock.calls.CreateProfessional, callInfo)
	mock.lockCreateProfessional.Unlock()
	return mock.CreateProfessionalFunc(ctx, professional)
}

// CreateProfessionalCalls gets all the calls that were made to CreateProfessional.
// Check the length with:
//
//	len(mockedStorage.CreateProfessionalCalls())
func (mock *StorageMock) CreateProfessionalCalls() []struct {
	Ctx          context.Context
	Professional domain.Professional
} {
	var calls []struct {
		Ctx          context.Context
		Professional domain.Professional
	}
	mock.lockCreateProfessional.RLock()
	calls = mock.calls.CreateProfessional
	mock.lockCreateProfessional.RUnlock()
	return calls
}

// CreateSession calls CreateSessionFunc.
func (mock *StorageMock) CreateSession(ctx context.Context, session entities.Session) error {
	if mock.CreateSessionFunc == nil {
		panic("StorageMock.CreateSessionFunc: method is nil but Storage.CreateSession was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Session entities.Session
	}{
		Ctx:     ctx,
		Session: session,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, session)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedStorage.CreateSessionCalls())
func (mock *StorageMock) CreateSessionCalls() []struct {
	Ctx     context.Context
	Session entities.Session
} {
	var calls []struct {
		Ctx     context.Context
		Session entities.Session
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// CreateUser calls CreateUserFunc.
func (mock *StorageMock) CreateUser(ctx context.Context, user domain.User) (domain.User, error) {
	if mock.CreateUserFunc == nil {
		panic("StorageMock.CreateUserFunc: method is nil but Storage.CreateUser was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		User domain.User
	}{
		Ctx:  ctx,
		User: user,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(ctx, user)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedStorage.CreateUserCalls())
func (mock *StorageMock) CreateUserCalls() []struct {
	Ctx  context.Context
	User domain.User
} {
	var calls []struct {
		Ctx  context.Context
		User domain.User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// DeleteExpiredSessions calls DeleteExpiredSessionsFunc.
func (mock *StorageMock) DeleteExpiredSessions(ctx context.Context) error {
	if mock.DeleteExpiredSessionsFunc == nil {
		panic("StorageMock.DeleteExpiredSessionsFunc: method is nil but Storage.DeleteExpiredSessions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteExpiredSessions.Lock()
	mock.calls.DeleteExpiredSessions = append(mock.calls.DeleteExpiredSessions, callInfo)
	mock.lockDeleteExpiredSessions.Unlock()
	return mock.DeleteExpiredSessionsFunc(ctx)
}

// DeleteExpiredSessionsCalls gets all the calls that were made to DeleteExpiredSessions.
// Check the length with:
//
//	len(mockedStorage.DeleteExpiredSessionsCalls())
func (mock *StorageMock) DeleteExpiredSessionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeleteExpiredSessions.RLock()
	calls = mock.calls.DeleteExpiredSessions
	mock.lockDeleteExpiredSessions.RUnlock()
	return calls
}

// DeleteSession calls DeleteSessionFunc.
func (mock *StorageMock) DeleteSession(ctx context.Context, token string) error {
	if mock.DeleteSessionFunc == nil {
		panic("StorageMock.DeleteSessionFunc: method is nil but Storage.DeleteSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	return mock.DeleteSessionFunc(ctx, token)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedStorage.DeleteSessionCalls())
func (mock *StorageMock) DeleteSessionCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// FindProfessionalsByLocation calls FindProfessionalsByLocationFunc.
func (mock *StorageMock) FindProfessionalsByLocation(ctx context.Context, department string, district string) ([]domain.Professional, error) {
	if mock.FindProfessionalsByLocationFunc == nil {
		panic("StorageMock.FindProfessionalsByLocationFunc: method is nil but Storage.FindProfessionalsByLocation was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Department string
		District   string
	}{
		Ctx:        ctx,
		Department: department,
		District:   district,
	}
	mock.lockFindProfessionalsByLocation.Lock()
	mock.calls.FindProfessionalsByLocation = append(mock.calls.FindProfessionalsByLocation, callInfo)
	mock.lockFindProfessionalsByLocation.Unlock()
	return mock.FindProfessionalsByLocationFunc(ctx, department, district)
}

// FindProfessionalsByLocationCalls gets all the calls that were made to FindProfessionalsByLocation.
// Check the length with:
//
//	len(mockedStorage.FindProfessionalsByLocationCalls())
func (mock *StorageMock) FindProfessionalsByLocationCalls() []struct {
	Ctx        context.Context
	Department string
	District   string
} {
	var calls []struct {
		Ctx        context.Context
		Department string
		District   string
	}
	mock.lockFindProfessionalsByLocation.RLock()
	calls = mock.calls.FindProfessionalsByLocation
	mock.lockFindProfessionalsByLocation.RUnlock()
	return calls
}

// FindProfessionalsByLocationAndProfession calls FindProfessionalsByLocationAndProfessionFunc.
func (mock *StorageMock) FindProfessionalsByLocationAndProfession(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error) {
	if mock.FindProfessionalsByLocationAndProfessionFunc == nil {
		panic("StorageMock.FindProfessionalsByLocationAndProfessionFunc: method is nil but Storage.FindProfessionalsByLocationAndProfession was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Department string
		District   string
		Profession string
	}{
		Ctx:        ctx,
		Department: department,
		District:   district,
		Profession: profession,
	}
	mock.lockFindProfessionalsByLocationAndProfession.Lock()
	mock.calls.FindProfessionalsByLocationAndProfession = append(mock.calls.FindProfessionalsByLocationAndProfession, callInfo)
	mock.lockFindProfessionalsByLocationAndProfession.Unlock()
	return mock.FindProfessionalsByLocationAndProfessionFunc(ctx, department, district, profession)
}

// FindProfessionalsByLocationAndProfessionCalls gets all the calls that were made to FindProfessionalsByLocationAndProfession.
// Check the length with:
//
//	len(mockedStorage.FindProfessionalsByLocationAndProfessionCalls())
func (mock *StorageMock) FindProfessionalsByLocationAndProfessionCalls() []struct {
	Ctx        context.Context
	Department string
	District   string
	Profession string
} {
	var calls []struct {
		Ctx        context.Context
		Department string
		District   string
		Profession string
	}
	mock.lockFindProfessionalsByLocationAndProfession.RLock()
	calls = mock.calls.FindProfessionalsByLocationAndProfession
	mock.lockFindProfessionalsByLocationAndProfession.RUnlock()
	return calls
}

// GetProfessionalByEmail calls GetProfessionalByEmailFunc.
func (mock *StorageMock) GetProfessionalByEmail(ctx context.Context, email string) (domain.Professional, error) {
	if mock.GetProfessionalByEmailFunc == nil {
		panic("StorageMock.GetProfessionalByEmailFunc: method is nil but Storage.GetProfessionalByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetProfessionalByEmail.Lock()
	mock.calls.GetProfessionalByEmail = append(mock.calls.GetProfessionalByEmail, callInfo)
	mock.lockGetProfessionalByEmail.Unlock()
	return mock.GetProfessionalByEmailFunc(ctx, email)
}

// GetProfessionalByEmailCalls gets all the calls that were made to GetProfessionalByEmail.
// Check the length with:
//
//	len(mockedStorage.GetProfessionalByEmailCalls())
func (mock *StorageMock) GetProfessionalByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetProfessionalByEmail.RLock()
	calls = mock.calls.GetProfessionalByEmail
	mock.lockGetProfessionalByEmail.RUnlock()
	return calls
}

// GetProfessionalByID calls GetProfessionalByIDFunc.
func (mock *StorageMock) GetProfessionalByID(ctx context.Context, ID uint64) (domain.Professional, error) {
	if mock.GetProfessionalByIDFunc == nil {
		panic("StorageMock.GetProfessionalByIDFunc: method is nil but Storage.GetProfessionalByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetProfessionalByID.Lock()
	mock.calls.GetProfessionalByID = append(mock.calls.GetProfessionalByID, callInfo)
	mock.lockGetProfessionalByID.Unlock()
	return mock.GetProfessionalByIDFunc(ctx, ID)
}

// GetProfessionalByIDCalls gets all the calls that were made to GetProfessionalByID.
// Check the length with:
//
//	len(mockedStorage.GetProfessionalByIDCalls())
func (mock *StorageMock) GetProfessionalByIDCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockGetProfessionalByID.RLock()
	calls = mock.calls.GetProfessionalByID
	mock.lockGetProfessionalByID.RUnlock()
	return calls
}

// GetProfessionalByUsername calls GetProfessionalByUsernameFunc.
func (mock *StorageMock) GetProfessionalByUsername(ctx context.Context, username string) (domain.Professional, error) {
	if mock.GetProfessionalByUsernameFunc == nil {
		panic("StorageMock.GetProfessionalByUsernameFunc: method is nil but Storage.GetProfessionalByUsername was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockGetProfessionalByUsername.Lock()
	mock.calls.GetProfessionalByUsername = append(mock.calls.GetProfessionalByUsername, callInfo)
	mock.lockGetProfessionalByUsername.Unlock()
	return mock.GetProfessionalByUsernameFunc(ctx, username)
}

// GetProfessionalByUsernameCalls gets all the calls that were made to GetProfessionalByUsername.
// Check the length with:
//
//	len(mockedStorage.GetProfessionalByUsernameCalls())
func (mock *StorageMock) GetProfessionalByUsernameCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockGetProfessionalByUsername.RLock()
	calls = mock.calls.GetProfessionalByUsername
	mock.lockGetProfessionalByUsername.RUnlock()
	return calls
}

// GetSessionByToken calls GetSessionByTokenFunc.
func (mock *StorageMock) GetSessionByToken(ctx context.Context, token string) (entities.Session, error) {
	if mock.GetSessionByTokenFunc == nil {
		panic("StorageMock.GetSessionByTokenFunc: method is nil but Storage.GetSessionByToken was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockGetSessionByToken.Lock()
	mock.calls.GetSessionByToken = append(mock.calls.GetSessionByToken, callInfo)
	mock.lockGetSessionByToken.Unlock()
	return mock.GetSessionByTokenFunc(ctx, token)
}

// GetSessionByTokenCalls gets all the calls that were made to GetSessionByToken.
// Check the length with:
//
//	len(mockedStorage.GetSessionByTokenCalls())
func (mock *StorageMock) GetSessionByTokenCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockGetSessionByToken.RLock()
	calls = mock.calls.GetSessionByToken
	mock.lockGetSessionByToken.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *StorageMock) GetUserByEmail(ctx context.Context, email string) (domain.User, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("StorageMock.GetUserByEmailFunc: method is nil but Storage.GetUserByEmail was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Email string
	}{
		Ctx:   ctx,
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(ctx, email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedStorage.GetUserByEmailCalls())
func (mock *StorageMock) GetUserByEmailCalls() []struct {
	Ctx   context.Context
	Email string
} {
	var calls []struct {
		Ctx   context.Context
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *StorageMock) GetUserByID(ctx context.Context, ID uint64) (domain.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("StorageMock.GetUserByIDFunc: method is nil but Storage.GetUserByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(ctx, ID)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedStorage.GetUserByIDCalls())
func (mock *StorageMock) GetUserByIDCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// GetUserByUsername calls GetUserByUsernameFunc.
func (mock *StorageMock) GetUserByUsername(ctx context.Context, username string) (domain.User, error) {
	if mock.GetUserByUsernameFunc == nil {
		panic("StorageMock.GetUserByUsernameFunc: method is nil but Storage.GetUserByUsername was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Username string
	}{
		Ctx:      ctx,
		Username: username,
	}
	mock.lockGetUserByUsername.Lock()
	mock.calls.GetUserByUsername = append(mock.calls.GetUserByUsername, callInfo)
	mock.lockGetUserByUsername.Unlock()
	return mock.GetUserByUsernameFunc(ctx, username)
}

// GetUserByUsernameCalls gets all the calls that were made to GetUserByUsername.
// Check the length with:
//
//	len(mockedStorage.GetUserByUsernameCalls())
func (mock *StorageMock) GetUserByUsernameCalls() []struct {
	Ctx      context.Context
	Username string
} {
	var calls []struct {
		Ctx      context.Context
		Username string
	}
	mock.lockGetUserByUsername.RLock()
	calls = mock.calls.GetUserByUsername
	mock.lockGetUserByUsername.RUnlock()
	return calls
}
