// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/jizambrana5/quickfix-back/pkg/domain"
	"github.com/jizambrana5/quickfix-back/pkg/entities"
	"sync"
	"time"
)

// UserServiceMock is a mock implementation of rest.UserService.
//
//	func TestSomethingThatUsesUserService(t *testing.T) {
//
//		// make and configure a mocked rest.UserService
//		mockedUserService := &UserServiceMock{
//			CreateSessionFunc: func(ctx context.Context, userID uint64) (string, error) {
//				panic("mock out the CreateSession method")
//			},
//			DeleteExpiredSessionsFunc: func(ctx context.Context) error {
//				panic("mock out the DeleteExpiredSessions method")
//			},
//			DeleteSessionFunc: func(ctx context.Context, token string) error {
//				panic("mock out the DeleteSession method")
//			},
//			FindProfessionalsByLocationFunc: func(ctx context.Context, department string, district string) ([]domain.Professional, error) {
//				panic("mock out the FindProfessionalsByLocation method")
//			},
//			FindProfessionalsByLocationAndProfessionFunc: func(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error) {
//				panic("mock out the FindProfessionalsByLocationAndProfession method")
//			},
//			GetProfessionalFunc: func(ctx context.Context, ID uint64) (domain.Professional, error) {
//				panic("mock out the GetProfessional method")
//			},
//			GetUserFunc: func(ctx context.Context, ID uint64) (domain.User, error) {
//				panic("mock out the GetUser method")
//			},
//			LoginProfessionalFunc: func(ctx context.Context, email string, password string) (domain.Professional, string, error) {
//				panic("mock out the LoginProfessional method")
//			},
//			LoginUserFunc: func(ctx context.Context, email string, password string) (domain.User, string, error) {
//				panic("mock out the LoginUser method")
//			},
//			RegisterProfessionalFunc: func(ctx context.Context, professionalReq entities.RegisterProfessionalRequest) (domain.Professional, error) {
//				panic("mock out the RegisterProfessional method")
//			},
//			RegisterUserFunc: func(ctx context.Context, userReq entities.RegisterUserRequest) (domain.User, error) {
//				panic("mock out the RegisterUser method")
//			},
//			ValidateSessionFunc: func(ctx context.Context, token string) (entities.Session, error) {
//				panic("mock out the ValidateSession method")
//			},
//		}
//
//		// use mockedUserService in code that requires rest.UserService
//		// and then make assertions.
//
//	}
type UserServiceMock struct {
	// CreateSessionFunc mocks the CreateSession method.
	CreateSessionFunc func(ctx context.Context, userID uint64) (string, error)

	// DeleteExpiredSessionsFunc mocks the DeleteExpiredSessions method.
	DeleteExpiredSessionsFunc func(ctx context.Context) error

	// DeleteSessionFunc mocks the DeleteSession method.
	DeleteSessionFunc func(ctx context.Context, token string) error

	// FindProfessionalsByLocationFunc mocks the FindProfessionalsByLocation method.
	FindProfessionalsByLocationFunc func(ctx context.Context, department string, district string) ([]domain.Professional, error)

	// FindProfessionalsByLocationAndProfessionFunc mocks the FindProfessionalsByLocationAndProfession method.
	FindProfessionalsByLocationAndProfessionFunc func(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error)

	// GetProfessionalFunc mocks the GetProfessional method.
	GetProfessionalFunc func(ctx context.Context, ID uint64) (domain.Professional, error)

	// GetUserFunc mocks the GetUser method.
	GetUserFunc func(ctx context.Context, ID uint64) (domain.User, error)

	// LoginProfessionalFunc mocks the LoginProfessional method.
	LoginProfessionalFunc func(ctx context.Context, email string, password string) (domain.Professional, string, error)

	// LoginUserFunc mocks the LoginUser method.
	LoginUserFunc func(ctx context.Context, email string, password string) (domain.User, string, error)

	// RegisterProfessionalFunc mocks the RegisterProfessional method.
	RegisterProfessionalFunc func(ctx context.Context, professionalReq entities.RegisterProfessionalRequest) (domain.Professional, error)

	// RegisterUserFunc mocks the RegisterUser method.
	RegisterUserFunc func(ctx context.Context, userReq entities.RegisterUserRequest) (domain.User, error)

	// ValidateSessionFunc mocks the ValidateSession method.
	ValidateSessionFunc func(ctx context.Context, token string) (entities.Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateSession holds details about calls to the CreateSession method.
		CreateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint64
		}
		// DeleteExpiredSessions holds details about calls to the DeleteExpiredSessions method.
		DeleteExpiredSessions []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// DeleteSession holds details about calls to the DeleteSession method.
		DeleteSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
		// FindProfessionalsByLocation holds details about calls to the FindProfessionalsByLocation method.
		FindProfessionalsByLocation []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Department is the department argument value.
			Department string
			// District is the district argument value.
			District string
		}
		// FindProfessionalsByLocationAndProfession holds details about calls to the FindProfessionalsByLocationAndProfession method.
		FindProfessionalsByLocationAndProfession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Department is the department argument value.
			Department string
			// District is the district argument value.
			District string
			// Profession is the profession argument value.
			Profession string
		}
		// GetProfessional holds details about calls to the GetProfessional method.
		GetProfessional []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID uint64
		}
		// GetUser holds details about calls to the GetUser method.
		GetUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID uint64
		}
		// LoginProfessional holds details about calls to the LoginProfessional method.
		LoginProfessional []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Password is the password argument value.
			Password string
		}
		// LoginUser holds details about calls to the LoginUser method.
		LoginUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Email is the email argument value.
			Email string
			// Password is the password argument value.
			Password string
		}
		// RegisterProfessional holds details about calls to the RegisterProfessional method.
		RegisterProfessional []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProfessionalReq is the professionalReq argument value.
			ProfessionalReq entities.RegisterProfessionalRequest
		}
		// RegisterUser holds details about calls to the RegisterUser method.
		RegisterUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserReq is the userReq argument value.
			UserReq entities.RegisterUserRequest
		}
		// ValidateSession holds details about calls to the ValidateSession method.
		ValidateSession []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Token is the token argument value.
			Token string
		}
	}
	lockCreateSession                            sync.RWMutex
	lockDeleteExpiredSessions                    sync.RWMutex
	lockDeleteSession                            sync.RWMutex
	lockFindProfessionalsByLocation              sync.RWMutex
	lockFindProfessionalsByLocationAndProfession sync.RWMutex
	lockGetProfessional                          sync.RWMutex
	lockGetUser                                  sync.RWMutex
	lockLoginProfessional                        sync.RWMutex
	lockLoginUser                                sync.RWMutex
	lockRegisterProfessional                     sync.RWMutex
	lockRegisterUser                             sync.RWMutex
	lockValidateSession                          sync.RWMutex
}

// CreateSession calls CreateSessionFunc.
func (mock *UserServiceMock) CreateSession(ctx context.Context, userID uint64) (string, error) {
	if mock.CreateSessionFunc == nil {
		panic("UserServiceMock.CreateSessionFunc: method is nil but UserService.CreateSession was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uint64
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockCreateSession.Lock()
	mock.calls.CreateSession = append(mock.calls.CreateSession, callInfo)
	mock.lockCreateSession.Unlock()
	return mock.CreateSessionFunc(ctx, userID)
}

// CreateSessionCalls gets all the calls that were made to CreateSession.
// Check the length with:
//
//	len(mockedUserService.CreateSessionCalls())
func (mock *UserServiceMock) CreateSessionCalls() []struct {
	Ctx    context.Context
	UserID uint64
} {
	var calls []struct {
		Ctx    context.Context
		UserID uint64
	}
	mock.lockCreateSession.RLock()
	calls = mock.calls.CreateSession
	mock.lockCreateSession.RUnlock()
	return calls
}

// DeleteExpiredSessions calls DeleteExpiredSessionsFunc.
func (mock *UserServiceMock) DeleteExpiredSessions(ctx context.Context) error {
	if mock.DeleteExpiredSessionsFunc == nil {
		panic("UserServiceMock.DeleteExpiredSessionsFunc: method is nil but UserService.DeleteExpiredSessions was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockDeleteExpiredSessions.Lock()
	mock.calls.DeleteExpiredSessions = append(mock.calls.DeleteExpiredSessions, callInfo)
	mock.lockDeleteExpiredSessions.Unlock()
	return mock.DeleteExpiredSessionsFunc(ctx)
}

// DeleteExpiredSessionsCalls gets all the calls that were made to DeleteExpiredSessions.
// Check the length with:
//
//	len(mockedUserService.DeleteExpiredSessionsCalls())
func (mock *UserServiceMock) DeleteExpiredSessionsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockDeleteExpiredSessions.RLock()
	calls = mock.calls.DeleteExpiredSessions
	mock.lockDeleteExpiredSessions.RUnlock()
	return calls
}

// DeleteSession calls DeleteSessionFunc.
func (mock *UserServiceMock) DeleteSession(ctx context.Context, token string) error {
	if mock.DeleteSessionFunc == nil {
		panic("UserServiceMock.DeleteSessionFunc: method is nil but UserService.DeleteSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockDeleteSession.Lock()
	mock.calls.DeleteSession = append(mock.calls.DeleteSession, callInfo)
	mock.lockDeleteSession.Unlock()
	return mock.DeleteSessionFunc(ctx, token)
}

// DeleteSessionCalls gets all the calls that were made to DeleteSession.
// Check the length with:
//
//	len(mockedUserService.DeleteSessionCalls())
func (mock *UserServiceMock) DeleteSessionCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockDeleteSession.RLock()
	calls = mock.calls.DeleteSession
	mock.lockDeleteSession.RUnlock()
	return calls
}

// FindProfessionalsByLocation calls FindProfessionalsByLocationFunc.
func (mock *UserServiceMock) FindProfessionalsByLocation(ctx context.Context, department string, district string) ([]domain.Professional, error) {
	if mock.FindProfessionalsByLocationFunc == nil {
		panic("UserServiceMock.FindProfessionalsByLocationFunc: method is nil but UserService.FindProfessionalsByLocation was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Department string
		District   string
	}{
		Ctx:        ctx,
		Department: department,
		District:   district,
	}
	mock.lockFindProfessionalsByLocation.Lock()
	mock.calls.FindProfessionalsByLocation = append(mock.calls.FindProfessionalsByLocation, callInfo)
	mock.lockFindProfessionalsByLocation.Unlock()
	return mock.FindProfessionalsByLocationFunc(ctx, department, district)
}

// FindProfessionalsByLocationCalls gets all the calls that were made to FindProfessionalsByLocation.
// Check the length with:
//
//	len(mockedUserService.FindProfessionalsByLocationCalls())
func (mock *UserServiceMock) FindProfessionalsByLocationCalls() []struct {
	Ctx        context.Context
	Department string
	District   string
} {
	var calls []struct {
		Ctx        context.Context
		Department string
		District   string
	}
	mock.lockFindProfessionalsByLocation.RLock()
	calls = mock.calls.FindProfessionalsByLocation
	mock.lockFindProfessionalsByLocation.RUnlock()
	return calls
}

// FindProfessionalsByLocationAndProfession calls FindProfessionalsByLocationAndProfessionFunc.
func (mock *UserServiceMock) FindProfessionalsByLocationAndProfession(ctx context.Context, department string, district string, profession string) ([]domain.Professional, error) {
	if mock.FindProfessionalsByLocationAndProfessionFunc == nil {
		panic("UserServiceMock.FindProfessionalsByLocationAndProfessionFunc: method is nil but UserService.FindProfessionalsByLocationAndProfession was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Department string
		District   string
		Profession string
	}{
		Ctx:        ctx,
		Department: department,
		District:   district,
		Profession: profession,
	}
	mock.lockFindProfessionalsByLocationAndProfession.Lock()
	mock.calls.FindProfessionalsByLocationAndProfession = append(mock.calls.FindProfessionalsByLocationAndProfession, callInfo)
	mock.lockFindProfessionalsByLocationAndProfession.Unlock()
	return mock.FindProfessionalsByLocationAndProfessionFunc(ctx, department, district, profession)
}

// FindProfessionalsByLocationAndProfessionCalls gets all the calls that were made to FindProfessionalsByLocationAndProfession.
// Check the length with:
//
//	len(mockedUserService.FindProfessionalsByLocationAndProfessionCalls())
func (mock *UserServiceMock) FindProfessionalsByLocationAndProfessionCalls() []struct {
	Ctx        context.Context
	Department string
	District   string
	Profession string
} {
	var calls []struct {
		Ctx        context.Context
		Department string
		District   string
		Profession string
	}
	mock.lockFindProfessionalsByLocationAndProfession.RLock()
	calls = mock.calls.FindProfessionalsByLocationAndProfession
	mock.lockFindProfessionalsByLocationAndProfession.RUnlock()
	return calls
}

// GetProfessional calls GetProfessionalFunc.
func (mock *UserServiceMock) GetProfessional(ctx context.Context, ID uint64) (domain.Professional, error) {
	if mock.GetProfessionalFunc == nil {
		panic("UserServiceMock.GetProfessionalFunc: method is nil but UserService.GetProfessional was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetProfessional.Lock()
	mock.calls.GetProfessional = append(mock.calls.GetProfessional, callInfo)
	mock.lockGetProfessional.Unlock()
	return mock.GetProfessionalFunc(ctx, ID)
}

// GetProfessionalCalls gets all the calls that were made to GetProfessional.
// Check the length with:
//
//	len(mockedUserService.GetProfessionalCalls())
func (mock *UserServiceMock) GetProfessionalCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockGetProfessional.RLock()
	calls = mock.calls.GetProfessional
	mock.lockGetProfessional.RUnlock()
	return calls
}

// GetUser calls GetUserFunc.
func (mock *UserServiceMock) GetUser(ctx context.Context, ID uint64) (domain.User, error) {
	if mock.GetUserFunc == nil {
		panic("UserServiceMock.GetUserFunc: method is nil but UserService.GetUser was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetUser.Lock()
	mock.calls.GetUser = append(mock.calls.GetUser, callInfo)
	mock.lockGetUser.Unlock()
	return mock.GetUserFunc(ctx, ID)
}

// GetUserCalls gets all the calls that were made to GetUser.
// Check the length with:
//
//	len(mockedUserService.GetUserCalls())
func (mock *UserServiceMock) GetUserCalls() []struct {
	Ctx context.Context
	ID  uint64
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
	}
	mock.lockGetUser.RLock()
	calls = mock.calls.GetUser
	mock.lockGetUser.RUnlock()
	return calls
}

// LoginProfessional calls LoginProfessionalFunc.
func (mock *UserServiceMock) LoginProfessional(ctx context.Context, email string, password string) (domain.Professional, string, error) {
	if mock.LoginProfessionalFunc == nil {
		panic("UserServiceMock.LoginProfessionalFunc: method is nil but UserService.LoginProfessional was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Email    string
		Password string
	}{
		Ctx:      ctx,
		Email:    email,
		Password: password,
	}
	mock.lockLoginProfessional.Lock()
	mock.calls.LoginProfessional = append(mock.calls.LoginProfessional, callInfo)
	mock.lockLoginProfessional.Unlock()
	return mock.LoginProfessionalFunc(ctx, email, password)
}

// LoginProfessionalCalls gets all the calls that were made to LoginProfessional.
// Check the length with:
//
//	len(mockedUserService.LoginProfessionalCalls())
func (mock *UserServiceMock) LoginProfessionalCalls() []struct {
	Ctx      context.Context
	Email    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Email    string
		Password string
	}
	mock.lockLoginProfessional.RLock()
	calls = mock.calls.LoginProfessional
	mock.lockLoginProfessional.RUnlock()
	return calls
}

// LoginUser calls LoginUserFunc.
func (mock *UserServiceMock) LoginUser(ctx context.Context, email string, password string) (domain.User, string, error) {
	if mock.LoginUserFunc == nil {
		panic("UserServiceMock.LoginUserFunc: method is nil but UserService.LoginUser was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Email    string
		Password string
	}{
		Ctx:      ctx,
		Email:    email,
		Password: password,
	}
	mock.lockLoginUser.Lock()
	mock.calls.LoginUser = append(mock.calls.LoginUser, callInfo)
	mock.lockLoginUser.Unlock()
	return mock.LoginUserFunc(ctx, email, password)
}

// LoginUserCalls gets all the calls that were made to LoginUser.
// Check the length with:
//
//	len(mockedUserService.LoginUserCalls())
func (mock *UserServiceMock) LoginUserCalls() []struct {
	Ctx      context.Context
	Email    string
	Password string
} {
	var calls []struct {
		Ctx      context.Context
		Email    string
		Password string
	}
	mock.lockLoginUser.RLock()
	calls = mock.calls.LoginUser
	mock.lockLoginUser.RUnlock()
	return calls
}

// RegisterProfessional calls RegisterProfessionalFunc.
func (mock *UserServiceMock) RegisterProfessional(ctx context.Context, professionalReq entities.RegisterProfessionalRequest) (domain.Professional, error) {
	if mock.RegisterProfessionalFunc == nil {
		panic("UserServiceMock.RegisterProfessionalFunc: method is nil but UserService.RegisterProfessional was just called")
	}
	callInfo := struct {
		Ctx             context.Context
		ProfessionalReq entities.RegisterProfessionalRequest
	}{
		Ctx:             ctx,
		ProfessionalReq: professionalReq,
	}
	mock.lockRegisterProfessional.Lock()
	mock.calls.RegisterProfessional = append(mock.calls.RegisterProfessional, callInfo)
	mock.lockRegisterProfessional.Unlock()
	return mock.RegisterProfessionalFunc(ctx, professionalReq)
}

// RegisterProfessionalCalls gets all the calls that were made to RegisterProfessional.
// Check the length with:
//
//	len(mockedUserService.RegisterProfessionalCalls())
func (mock *UserServiceMock) RegisterProfessionalCalls() []struct {
	Ctx             context.Context
	ProfessionalReq entities.RegisterProfessionalRequest
} {
	var calls []struct {
		Ctx             context.Context
		ProfessionalReq entities.RegisterProfessionalRequest
	}
	mock.lockRegisterProfessional.RLock()
	calls = mock.calls.RegisterProfessional
	mock.lockRegisterProfessional.RUnlock()
	return calls
}

// RegisterUser calls RegisterUserFunc.
func (mock *UserServiceMock) RegisterUser(ctx context.Context, userReq entities.RegisterUserRequest) (domain.User, error) {
	if mock.RegisterUserFunc == nil {
		panic("UserServiceMock.RegisterUserFunc: method is nil but UserService.RegisterUser was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		UserReq entities.RegisterUserRequest
	}{
		Ctx:     ctx,
		UserReq: userReq,
	}
	mock.lockRegisterUser.Lock()
	mock.calls.RegisterUser = append(mock.calls.RegisterUser, callInfo)
	mock.lockRegisterUser.Unlock()
	return mock.RegisterUserFunc(ctx, userReq)
}

// RegisterUserCalls gets all the calls that were made to RegisterUser.
// Check the length with:
//
//	len(mockedUserService.RegisterUserCalls())
func (mock *UserServiceMock) RegisterUserCalls() []struct {
	Ctx     context.Context
	UserReq entities.RegisterUserRequest
} {
	var calls []struct {
		Ctx     context.Context
		UserReq entities.RegisterUserRequest
	}
	mock.lockRegisterUser.RLock()
	calls = mock.calls.RegisterUser
	mock.lockRegisterUser.RUnlock()
	return calls
}

// ValidateSession calls ValidateSessionFunc.
func (mock *UserServiceMock) ValidateSession(ctx context.Context, token string) (entities.Session, error) {
	if mock.ValidateSessionFunc == nil {
		panic("UserServiceMock.ValidateSessionFunc: method is nil but UserService.ValidateSession was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Token string
	}{
		Ctx:   ctx,
		Token: token,
	}
	mock.lockValidateSession.Lock()
	mock.calls.ValidateSession = append(mock.calls.ValidateSession, callInfo)
	mock.lockValidateSession.Unlock()
	return mock.ValidateSessionFunc(ctx, token)
}

// ValidateSessionCalls gets all the calls that were made to ValidateSession.
// Check the length with:
//
//	len(mockedUserService.ValidateSessionCalls())
func (mock *UserServiceMock) ValidateSessionCalls() []struct {
	Ctx   context.Context
	Token string
} {
	var calls []struct {
		Ctx   context.Context
		Token string
	}
	mock.lockValidateSession.RLock()
	calls = mock.calls.ValidateSession
	mock.lockValidateSession.RUnlock()
	return calls
}

// OrderServiceMock is a mock implementation of rest.OrderService.
//
//	func TestSomethingThatUsesOrderService(t *testing.T) {
//
//		// make and configure a mocked rest.OrderService
//		mockedOrderService := &OrderServiceMock{
//			AcceptOrderFunc: func(ctx context.Context, orderID string) (domain.Order, error) {
//				panic("mock out the AcceptOrder method")
//			},
//			CancelOrderFunc: func(ctx context.Context, orderID string) (domain.Order, error) {
//				panic("mock out the CancelOrder method")
//			},
//			CompleteOrderFunc: func(ctx context.Context, orderID string) (domain.Order, error) {
//				panic("mock out the CompleteOrder method")
//			},
//			CreateOrderFunc: func(ctx context.Context, order entities.CreateOrderRequest) (domain.Order, error) {
//				panic("mock out the CreateOrder method")
//			},
//			GetOrderFunc: func(ctx context.Context, ID string) (domain.Order, error) {
//				panic("mock out the GetOrder method")
//			},
//			GetOrdersByProfessionalFunc: func(ctx context.Context, professionalID uint64) ([]domain.Order, error) {
//				panic("mock out the GetOrdersByProfessional method")
//			},
//			GetOrdersByProfessionalAndDayFunc: func(ctx context.Context, id uint64, day time.Time) ([]domain.Order, error) {
//				panic("mock out the GetOrdersByProfessionalAndDay method")
//			},
//			GetOrdersByProfessionalAndScheduleToFunc: func(background context.Context, professionalID uint64, scheduleTo time.Time) ([]domain.Order, error) {
//				panic("mock out the GetOrdersByProfessionalAndScheduleTo method")
//			},
//			GetOrdersByUserFunc: func(ctx context.Context, userID uint64) ([]domain.Order, error) {
//				panic("mock out the GetOrdersByUser method")
//			},
//		}
//
//		// use mockedOrderService in code that requires rest.OrderService
//		// and then make assertions.
//
//	}
type OrderServiceMock struct {
	// AcceptOrderFunc mocks the AcceptOrder method.
	AcceptOrderFunc func(ctx context.Context, orderID string) (domain.Order, error)

	// CancelOrderFunc mocks the CancelOrder method.
	CancelOrderFunc func(ctx context.Context, orderID string) (domain.Order, error)

	// CompleteOrderFunc mocks the CompleteOrder method.
	CompleteOrderFunc func(ctx context.Context, orderID string) (domain.Order, error)

	// CreateOrderFunc mocks the CreateOrder method.
	CreateOrderFunc func(ctx context.Context, order entities.CreateOrderRequest) (domain.Order, error)

	// GetOrderFunc mocks the GetOrder method.
	GetOrderFunc func(ctx context.Context, ID string) (domain.Order, error)

	// GetOrdersByProfessionalFunc mocks the GetOrdersByProfessional method.
	GetOrdersByProfessionalFunc func(ctx context.Context, professionalID uint64) ([]domain.Order, error)

	// GetOrdersByProfessionalAndDayFunc mocks the GetOrdersByProfessionalAndDay method.
	GetOrdersByProfessionalAndDayFunc func(ctx context.Context, id uint64, day time.Time) ([]domain.Order, error)

	// GetOrdersByProfessionalAndScheduleToFunc mocks the GetOrdersByProfessionalAndScheduleTo method.
	GetOrdersByProfessionalAndScheduleToFunc func(background context.Context, professionalID uint64, scheduleTo time.Time) ([]domain.Order, error)

	// GetOrdersByUserFunc mocks the GetOrdersByUser method.
	GetOrdersByUserFunc func(ctx context.Context, userID uint64) ([]domain.Order, error)

	// calls tracks calls to the methods.
	calls struct {
		// AcceptOrder holds details about calls to the AcceptOrder method.
		AcceptOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderID is the orderID argument value.
			OrderID string
		}
		// CancelOrder holds details about calls to the CancelOrder method.
		CancelOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderID is the orderID argument value.
			OrderID string
		}
		// CompleteOrder holds details about calls to the CompleteOrder method.
		CompleteOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// OrderID is the orderID argument value.
			OrderID string
		}
		// CreateOrder holds details about calls to the CreateOrder method.
		CreateOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Order is the order argument value.
			Order entities.CreateOrderRequest
		}
		// GetOrder holds details about calls to the GetOrder method.
		GetOrder []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the ID argument value.
			ID string
		}
		// GetOrdersByProfessional holds details about calls to the GetOrdersByProfessional method.
		GetOrdersByProfessional []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProfessionalID is the professionalID argument value.
			ProfessionalID uint64
		}
		// GetOrdersByProfessionalAndDay holds details about calls to the GetOrdersByProfessionalAndDay method.
		GetOrdersByProfessionalAndDay []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uint64
			// Day is the day argument value.
			Day time.Time
		}
		// GetOrdersByProfessionalAndScheduleTo holds details about calls to the GetOrdersByProfessionalAndScheduleTo method.
		GetOrdersByProfessionalAndScheduleTo []struct {
			// Background is the background argument value.
			Background context.Context
			// ProfessionalID is the professionalID argument value.
			ProfessionalID uint64
			// ScheduleTo is the scheduleTo argument value.
			ScheduleTo time.Time
		}
		// GetOrdersByUser holds details about calls to the GetOrdersByUser method.
		GetOrdersByUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// UserID is the userID argument value.
			UserID uint64
		}
	}
	lockAcceptOrder                          sync.RWMutex
	lockCancelOrder                          sync.RWMutex
	lockCompleteOrder                        sync.RWMutex
	lockCreateOrder                          sync.RWMutex
	lockGetOrder                             sync.RWMutex
	lockGetOrdersByProfessional              sync.RWMutex
	lockGetOrdersByProfessionalAndDay        sync.RWMutex
	lockGetOrdersByProfessionalAndScheduleTo sync.RWMutex
	lockGetOrdersByUser                      sync.RWMutex
}

// AcceptOrder calls AcceptOrderFunc.
func (mock *OrderServiceMock) AcceptOrder(ctx context.Context, orderID string) (domain.Order, error) {
	if mock.AcceptOrderFunc == nil {
		panic("OrderServiceMock.AcceptOrderFunc: method is nil but OrderService.AcceptOrder was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OrderID string
	}{
		Ctx:     ctx,
		OrderID: orderID,
	}
	mock.lockAcceptOrder.Lock()
	mock.calls.AcceptOrder = append(mock.calls.AcceptOrder, callInfo)
	mock.lockAcceptOrder.Unlock()
	return mock.AcceptOrderFunc(ctx, orderID)
}

// AcceptOrderCalls gets all the calls that were made to AcceptOrder.
// Check the length with:
//
//	len(mockedOrderService.AcceptOrderCalls())
func (mock *OrderServiceMock) AcceptOrderCalls() []struct {
	Ctx     context.Context
	OrderID string
} {
	var calls []struct {
		Ctx     context.Context
		OrderID string
	}
	mock.lockAcceptOrder.RLock()
	calls = mock.calls.AcceptOrder
	mock.lockAcceptOrder.RUnlock()
	return calls
}

// CancelOrder calls CancelOrderFunc.
func (mock *OrderServiceMock) CancelOrder(ctx context.Context, orderID string) (domain.Order, error) {
	if mock.CancelOrderFunc == nil {
		panic("OrderServiceMock.CancelOrderFunc: method is nil but OrderService.CancelOrder was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OrderID string
	}{
		Ctx:     ctx,
		OrderID: orderID,
	}
	mock.lockCancelOrder.Lock()
	mock.calls.CancelOrder = append(mock.calls.CancelOrder, callInfo)
	mock.lockCancelOrder.Unlock()
	return mock.CancelOrderFunc(ctx, orderID)
}

// CancelOrderCalls gets all the calls that were made to CancelOrder.
// Check the length with:
//
//	len(mockedOrderService.CancelOrderCalls())
func (mock *OrderServiceMock) CancelOrderCalls() []struct {
	Ctx     context.Context
	OrderID string
} {
	var calls []struct {
		Ctx     context.Context
		OrderID string
	}
	mock.lockCancelOrder.RLock()
	calls = mock.calls.CancelOrder
	mock.lockCancelOrder.RUnlock()
	return calls
}

// CompleteOrder calls CompleteOrderFunc.
func (mock *OrderServiceMock) CompleteOrder(ctx context.Context, orderID string) (domain.Order, error) {
	if mock.CompleteOrderFunc == nil {
		panic("OrderServiceMock.CompleteOrderFunc: method is nil but OrderService.CompleteOrder was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		OrderID string
	}{
		Ctx:     ctx,
		OrderID: orderID,
	}
	mock.lockCompleteOrder.Lock()
	mock.calls.CompleteOrder = append(mock.calls.CompleteOrder, callInfo)
	mock.lockCompleteOrder.Unlock()
	return mock.CompleteOrderFunc(ctx, orderID)
}

// CompleteOrderCalls gets all the calls that were made to CompleteOrder.
// Check the length with:
//
//	len(mockedOrderService.CompleteOrderCalls())
func (mock *OrderServiceMock) CompleteOrderCalls() []struct {
	Ctx     context.Context
	OrderID string
} {
	var calls []struct {
		Ctx     context.Context
		OrderID string
	}
	mock.lockCompleteOrder.RLock()
	calls = mock.calls.CompleteOrder
	mock.lockCompleteOrder.RUnlock()
	return calls
}

// CreateOrder calls CreateOrderFunc.
func (mock *OrderServiceMock) CreateOrder(ctx context.Context, order entities.CreateOrderRequest) (domain.Order, error) {
	if mock.CreateOrderFunc == nil {
		panic("OrderServiceMock.CreateOrderFunc: method is nil but OrderService.CreateOrder was just called")
	}
	callInfo := struct {
		Ctx   context.Context
		Order entities.CreateOrderRequest
	}{
		Ctx:   ctx,
		Order: order,
	}
	mock.lockCreateOrder.Lock()
	mock.calls.CreateOrder = append(mock.calls.CreateOrder, callInfo)
	mock.lockCreateOrder.Unlock()
	return mock.CreateOrderFunc(ctx, order)
}

// CreateOrderCalls gets all the calls that were made to CreateOrder.
// Check the length with:
//
//	len(mockedOrderService.CreateOrderCalls())
func (mock *OrderServiceMock) CreateOrderCalls() []struct {
	Ctx   context.Context
	Order entities.CreateOrderRequest
} {
	var calls []struct {
		Ctx   context.Context
		Order entities.CreateOrderRequest
	}
	mock.lockCreateOrder.RLock()
	calls = mock.calls.CreateOrder
	mock.lockCreateOrder.RUnlock()
	return calls
}

// GetOrder calls GetOrderFunc.
func (mock *OrderServiceMock) GetOrder(ctx context.Context, ID string) (domain.Order, error) {
	if mock.GetOrderFunc == nil {
		panic("OrderServiceMock.GetOrderFunc: method is nil but OrderService.GetOrder was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  string
	}{
		Ctx: ctx,
		ID:  ID,
	}
	mock.lockGetOrder.Lock()
	mock.calls.GetOrder = append(mock.calls.GetOrder, callInfo)
	mock.lockGetOrder.Unlock()
	return mock.GetOrderFunc(ctx, ID)
}

// GetOrderCalls gets all the calls that were made to GetOrder.
// Check the length with:
//
//	len(mockedOrderService.GetOrderCalls())
func (mock *OrderServiceMock) GetOrderCalls() []struct {
	Ctx context.Context
	ID  string
} {
	var calls []struct {
		Ctx context.Context
		ID  string
	}
	mock.lockGetOrder.RLock()
	calls = mock.calls.GetOrder
	mock.lockGetOrder.RUnlock()
	return calls
}

// GetOrdersByProfessional calls GetOrdersByProfessionalFunc.
func (mock *OrderServiceMock) GetOrdersByProfessional(ctx context.Context, professionalID uint64) ([]domain.Order, error) {
	if mock.GetOrdersByProfessionalFunc == nil {
		panic("OrderServiceMock.GetOrdersByProfessionalFunc: method is nil but OrderService.GetOrdersByProfessional was just called")
	}
	callInfo := struct {
		Ctx            context.Context
		ProfessionalID uint64
	}{
		Ctx:            ctx,
		ProfessionalID: professionalID,
	}
	mock.lockGetOrdersByProfessional.Lock()
	mock.calls.GetOrdersByProfessional = append(mock.calls.GetOrdersByProfessional, callInfo)
	mock.lockGetOrdersByProfessional.Unlock()
	return mock.GetOrdersByProfessionalFunc(ctx, professionalID)
}

// GetOrdersByProfessionalCalls gets all the calls that were made to GetOrdersByProfessional.
// Check the length with:
//
//	len(mockedOrderService.GetOrdersByProfessionalCalls())
func (mock *OrderServiceMock) GetOrdersByProfessionalCalls() []struct {
	Ctx            context.Context
	ProfessionalID uint64
} {
	var calls []struct {
		Ctx            context.Context
		ProfessionalID uint64
	}
	mock.lockGetOrdersByProfessional.RLock()
	calls = mock.calls.GetOrdersByProfessional
	mock.lockGetOrdersByProfessional.RUnlock()
	return calls
}

// GetOrdersByProfessionalAndDay calls GetOrdersByProfessionalAndDayFunc.
func (mock *OrderServiceMock) GetOrdersByProfessionalAndDay(ctx context.Context, id uint64, day time.Time) ([]domain.Order, error) {
	if mock.GetOrdersByProfessionalAndDayFunc == nil {
		panic("OrderServiceMock.GetOrdersByProfessionalAndDayFunc: method is nil but OrderService.GetOrdersByProfessionalAndDay was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uint64
		Day time.Time
	}{
		Ctx: ctx,
		ID:  id,
		Day: day,
	}
	mock.lockGetOrdersByProfessionalAndDay.Lock()
	mock.calls.GetOrdersByProfessionalAndDay = append(mock.calls.GetOrdersByProfessionalAndDay, callInfo)
	mock.lockGetOrdersByProfessionalAndDay.Unlock()
	return mock.GetOrdersByProfessionalAndDayFunc(ctx, id, day)
}

// GetOrdersByProfessionalAndDayCalls gets all the calls that were made to GetOrdersByProfessionalAndDay.
// Check the length with:
//
//	len(mockedOrderService.GetOrdersByProfessionalAndDayCalls())
func (mock *OrderServiceMock) GetOrdersByProfessionalAndDayCalls() []struct {
	Ctx context.Context
	ID  uint64
	Day time.Time
} {
	var calls []struct {
		Ctx context.Context
		ID  uint64
		Day time.Time
	}
	mock.lockGetOrdersByProfessionalAndDay.RLock()
	calls = mock.calls.GetOrdersByProfessionalAndDay
	mock.lockGetOrdersByProfessionalAndDay.RUnlock()
	return calls
}

// GetOrdersByProfessionalAndScheduleTo calls GetOrdersByProfessionalAndScheduleToFunc.
func (mock *OrderServiceMock) GetOrdersByProfessionalAndScheduleTo(background context.Context, professionalID uint64, scheduleTo time.Time) ([]domain.Order, error) {
	if mock.GetOrdersByProfessionalAndScheduleToFunc == nil {
		panic("OrderServiceMock.GetOrdersByProfessionalAndScheduleToFunc: method is nil but OrderService.GetOrdersByProfessionalAndScheduleTo was just called")
	}
	callInfo := struct {
		Background     context.Context
		ProfessionalID uint64
		ScheduleTo     time.Time
	}{
		Background:     background,
		ProfessionalID: professionalID,
		ScheduleTo:     scheduleTo,
	}
	mock.lockGetOrdersByProfessionalAndScheduleTo.Lock()
	mock.calls.GetOrdersByProfessionalAndScheduleTo = append(mock.calls.GetOrdersByProfessionalAndScheduleTo, callInfo)
	mock.lockGetOrdersByProfessionalAndScheduleTo.Unlock()
	return mock.GetOrdersByProfessionalAndScheduleToFunc(background, professionalID, scheduleTo)
}

// GetOrdersByProfessionalAndScheduleToCalls gets all the calls that were made to GetOrdersByProfessionalAndScheduleTo.
// Check the length with:
//
//	len(mockedOrderService.GetOrdersByProfessionalAndScheduleToCalls())
func (mock *OrderServiceMock) GetOrdersByProfessionalAndScheduleToCalls() []struct {
	Background     context.Context
	ProfessionalID uint64
	ScheduleTo     time.Time
} {
	var calls []struct {
		Background     context.Context
		ProfessionalID uint64
		ScheduleTo     time.Time
	}
	mock.lockGetOrdersByProfessionalAndScheduleTo.RLock()
	calls = mock.calls.GetOrdersByProfessionalAndScheduleTo
	mock.lockGetOrdersByProfessionalAndScheduleTo.RUnlock()
	return calls
}

// GetOrdersByUser calls GetOrdersByUserFunc.
func (mock *OrderServiceMock) GetOrdersByUser(ctx context.Context, userID uint64) ([]domain.Order, error) {
	if mock.GetOrdersByUserFunc == nil {
		panic("OrderServiceMock.GetOrdersByUserFunc: method is nil but OrderService.GetOrdersByUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		UserID uint64
	}{
		Ctx:    ctx,
		UserID: userID,
	}
	mock.lockGetOrdersByUser.Lock()
	mock.calls.GetOrdersByUser = append(mock.calls.GetOrdersByUser, callInfo)
	mock.lockGetOrdersByUser.Unlock()
	return mock.GetOrdersByUserFunc(ctx, userID)
}

// GetOrdersByUserCalls gets all the calls that were made to GetOrdersByUser.
// Check the length with:
//
//	len(mockedOrderService.GetOrdersByUserCalls())
func (mock *OrderServiceMock) GetOrdersByUserCalls() []struct {
	Ctx    context.Context
	UserID uint64
} {
	var calls []struct {
		Ctx    context.Context
		UserID uint64
	}
	mock.lockGetOrdersByUser.RLock()
	calls = mock.calls.GetOrdersByUser
	mock.lockGetOrdersByUser.RUnlock()
	return calls
}
